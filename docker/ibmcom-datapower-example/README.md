# Purpose
Use the [IBM DataPower Gateway for Docker](https://hub.docker.com/r/ibmcom/datapower/) to demonstrate basic concepts of using the DataPower Gateway in conjunction with a Docker friendly software development life cycle.

This is applicable *only* to IBM DataPower Gateway for Docker which was introduced in DataPower v7.5.2. It does *not* apply to the IBM DataPower Gateway for Linux which is delivered as Debian and RPM packages. While the sample application is the same, the DataPower platform is different and the development speed, deployment speed, and Docker SDLC integration is much better when using DataPower for Docker instead of DataPower for Linux.

This project demonstrates how one might:

* Use the DataPower WebGUI as an IDE for DataPower configuration
* Easily edit Gatewayscript or xsl files such that they are immediately
  available inside DataPower with no further action required
* Use version control with DataPower configuration with the docker
  run --volume flag
* Customize containers at run time so they can consume Docker-provided
  environment variables and honor the docker run --link flag
* Build and test new images

## Contents

./Makefile -- the orchestrator. See comments for details of operation.

./src/drouter/config/auto-startup.cfg -- The saved DataPower default domain
configuration files.  These are saved by DataPower and carried as-is
into version control.

./src/drouter/config/foo/foo.cfg -- The saved DataPower domain foo
configuration.

./src/drouter/local/foo/hello-too.js -- Gatewayscript in support of
the domain foo Multi-Protocol gateway

./src/drouter/start.sh -- Startup script, runs the `/start/*` scripts
and then starts drouter itself.  This is the Dockerfile CMD.

./src/drouter/start/debug.sh -- Generates a log target at run time if
the Docker environment variable DEBUG is set, such as 'make DEBUG=true
run' or 'make DEBUG=true rundev'

./src/drouter/start/loadbalancer-group.sh -- Generates the loadbalancer-
group used by domain foo for back end servers.  The back end servers
are all linked Docker containers and run on port 8080.

## Concepts

The goal of this project is to completely, utterly, and unashamedly embrace the Docker SDLC (Software Development Life Cycle). At the same time, it is intended to be an extremely simple example with minimal prerequisites to demonstrate how DataPower may fit into an orchestration environment.

For our orchestrator, we will use a simple Makefile. It has the ability to automate all the actions that we want to demonstrate. For example:

A description of selected `Makefile` targets:
- `build`
  - docker build the image
- `rundev`
  - run `ibmcom/datapower` as a developer would.
  - `web-mgmt` is enabled;
  - volumes are used for configuration so that `write mem` or `Save config` inside DataPower cause the correct files to be saved in the source tree.
- `run`
  - runs the built image generated by this project
- `test`
  - runs the test harness to make sure that the container is working properly.
  - This is a stand in for any kind of automated testing that would be present in an orchestration environment.
- `tag`
  - Adds the `latest` tag to the output image
  - This indicates a good build that has passed `test`.
- `clean` `cleaner`
  - Remove generated files.
  - `clean` should always be run between `rundev` and `build`
  - `cleaner` also removes any generated keys.
- `gui`, `cli`, `shell`
  - Connect to an already-running container on `web-mgmt`, the `cli`, and in `/bin/sh` respectively.
- `rm` -- stop and remove running containers from `rundev` or `run`.
- `all` -- `make clean build run test tag`
  - This is the target that the build farm would run when triggered by a checkin
  - This is the target that a developer would use prior to check in
  - The developer would have a different repository than the build farm so there would be no name collisions.

A description of workflow for selected roles:
- Developer role
  1. `rundev`
    - `gui`, `cli` -- change configuration to DataPower itself
    - `shell` -- Work with early startup integration, such as the code that is run before `drouter` is started.
    - `test` -- run the test harness against the running container
    - Repeat until satisfied, then
  1. `all` -- unit test the result, then
  1. Check in changes
- Release Engineering / Build-Farm role
  1. `all` -- Does the complete build including test and tag
  1. `docker push` -- makes the image available beyond the build machine.
    - This could be for the use of the Software Quality Assurance team
    - Could be for release to next steps of Continuous Integration / Continuous delivery
    - At this point, you have a tested, tagged, and pushed image that is ready for the next step of deployment.
