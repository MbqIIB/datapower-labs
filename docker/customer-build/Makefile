# Instructions:
#
# Prereq:
# 1) Build the "-base" image image using deb2img
# 2) Build the "customer-commit" image using customer-commit
#
# This project:
# A) Like a builder: make
# This will build, run, test, and tag the resulting image.  If this completes,
# then the resulting image works.
#
# B) As a developer:
#  a) make rundev
#  b) Do development!
#  c) make test, if fail, goto b
#  d) make stop fixate clean build run test
#  f) Perform other manual tests. If tests fail, make rm rundev and goto b
#  g) If happy, check in any and all resulting files
#
# A note on naming conventions:
# * The registry defaults to USER.  Override at will. Add the registry prefix.
# * The repository defaults to customer-build.
# * The default name for a running container is "customer-build".  Override at will,
#   remember that the name of a container must be unique on this docker engine.
# * The repository of the committed image is the same as the name of the built image
# * The tagged image is the same repository, except the tag is "latest". instead
#   of the value of TAG, which defaults to 0.1.
#
# A note on working with multiple containers:
# * The default container name is "customer-build"
# * The "CONTAINER_NAME" variable can be specified on make or as an environment
#   variable.
# * One option is to have a window for each of several DataPower containers
# * And set CONTAINER_NAME=foo, where foo is unique in each window.
#
# How it works:
#
# We start from a license-accepted, secrets added DataPower Docker image. 
# The image already uses /datapower/local for local: and /datapower/config
# for config:.
#
# When we docker build the DataPower image, we add DataPower configuration
# to /datapower/local and /datapower/config. We also use our own CMD so
# we can run our own code prior to DataPower starting.  The code looks at
# the Docker environment and produces DataPower .cfg files in /datapower/config
# that is then loaded by a DataPower include-config.
#
# We place all of our content inside the /datapower directory. This aids both
# the docker build process and allows us to use /datapower as a docker volume
# when running in development mode. By mounting the /datapower directory as a
# volume, DataPower's "write mem" and WebGUI "Save" cause DataPower to write
# configuration to datapower/config/autoconfig.cfg and datapower/config/
# <domain>/<domain>.cfg. Additionally, direct editing on xsl and gatewayscript
# files is possible using one's favorite editor.
#
# When we run the resulting image, we either run it in development mode (rundev)
# or in unit test mode (run). The run target runs the built image without mounting
# volumes, so only the files built into the docker image are used. The rundev
# target runs the docker image using the datapower directory as a volume for
# /datapower.
#
# Examples of DataPower configuration that is inherited from the Docker environment
# is the DEBUG environment variable which controls some DataPower log targets and
# the creation of a load balancer group that allows distribution among all linked
# back-end servers on port 8080.
#
# This image can then be run and tested.  Once the image's validity is verified,
# it can be tagged as customer-build:latest for use in the customer-build project.
#
# The point of this step is to enable DataPower development workflows and
# and release engineering process. This is what allows DataPower docker images
# to be run everywhere, to adapt themselves to the running environment, and to
# integrate with deployment methodology.
#
# The resulting DataPower docker image is one that would be "docker push"ed to
# a private registry and deployed.
#
# The targets:
#
# rundev: Use this target for DataPower development.  DataPower runs, and the
# datapower/ directory is a volume.  Clicking 'save' in DataPower causes files
# to be saved in datapower/config and datapower/local where they can be used
# with version control.
#
# build: Performs the docker build.  After rundev and testing is working
# satisfactorily, use the build target to put datapower/ into a Docker image.
#
# shell: Run a bash shell inside the container
#
# gui: Load the DataPower WebGUI in firefox
#
# run: Run the built docker image
#
# test: Test the DataPower services deployed in the running container. The
# DataPower container must be running with either rundev or run first.
#
# stop: Stop the running container
#
# rm: Delete the container
#
# clean: Remove files generated by the Makefile and the non-persisted results
# of rundev
#
# fixate: Like a photocopier, fixate takes the docker/DataPower created files
# from dev mode and fixes the permissions so the ownership is consistent with
# the rest of the project.  Use this step after rundev and before build or
# version control operations.
#
# logs: Show the docker logs for the container
#
# tag: Add the :latest tag to the result docker image
#
# NUM_BACKENDS specifies how many back-end servers should be used. It
# defaults to 3. It must be specified on the run, rundev, test, and rm
# make targets.
#
# DEBUG can be used to enable a debug log target inside DataPower. It may
# be specified on the rundev or run targets.

REGISTRY ?= $(USER)
BASEREPOSITORY ?= customer-commit
RESULTREPOSITORY ?= customer-build
REPOSITORY = $(RESULTREPOSITORY)
TAG ?= 0.1
CONTAINER_NAME ?= customer-build
NUM_BACKENDS ?= 3

MAXWAIT = 600
DEBUG ?= 

RUNFLAGS = --privileged -P -e DEBUG="$(DEBUG)"

BACKEND_CONTAINER_NAMES = $(foreach backend, $(shell seq $(NUM_BACKENDS)), $(CONTAINER_NAME)-backend-$(backend))

.PHONY: all build shell evolve run rundev rm cli gui clean logs tag stop fixate test

all: clean build run test tag

# Make sure a listener is on a port before trying to connect with it
# Inside the container, check netstat once a second until the TCP
# port is in LISTEN.
define wait-for-listener
	@docker exec -it $(CONTAINER_NAME) /bin/bash -c \
	  'MSG="Waiting for port $(LISTENPORT) listener"; \
	  NL=""; \
	  for (( i=0, RC=1; i<$(MAXWAIT); i++ )); do \
	    netstat -ln | grep -q "^tcp.*:$(LISTENPORT).*LISTEN" \
	      && { RC=0; break; }; \
	    echo -n $$MSG; \
	    MSG=.; \
	    NL="\n"; \
	    sleep 1; \
	  done; \
	  echo -ne "$$NL"; \
	  exit $$RC'
endef

# The DOCKER_HOST variable may be unset or may contain tcp://1.2.3.4:1234
# We just want to know the address of the Docker Engine we're talking to
# so it's either the IP address portion of DOCKER_HOST or it's 127.0.0.1.
ifeq '$(DOCKER_HOST)' ''
  DP_DOCKER_HOST=127.0.0.1
  DP_VBOX_INOTIFY=
else
  # remove the leading tcp://, then replace the : with a " " so we have
  # 2 words.  Lastly take just the first word, which is just the IP address
  # portion of the DOCKER_HOST.
  DP_DOCKER_HOST=$(firstword $(subst :, ,$(patsubst tcp://%,%,$(DOCKER_HOST))))
  DP_VBOX_INOTIFY=-e DP_VBOX_INOTIFY=true
endif

rundev: RUNFLAGS+=-v $(PWD)/datapower:/datapower -p 443 $(DP_VBOX_INOTIFY)
rundev: LISTENPORT=2200
rundev: REPOSITORY=$(BASEREPOSITORY)
rundev: TAG=latest
rundev: datapower/config datapower/local run
rundev: CONTAINER_CMD=/datapower/start.sh

# The Dockerfile has to be generated so we can put the correct
# REGISTRY and BASEREPOSITORY into it
Dockerfile: Makefile
	echo '# Dockerfile generated by Makefile $(shell date)' > $@
	echo 'FROM $(REGISTRY)/$(BASEREPOSITORY):latest' >> $@
	echo 'COPY /datapower /datapower/' >> $@
	echo 'EXPOSE 9090 443' >> $@
	echo 'CMD ["/datapower/start.sh"]' >> $@


build: Dockerfile
	docker build -t $(REGISTRY)/$(RESULTREPOSITORY):$(TAG) .

shell:
	docker exec -it $(CONTAINER_NAME) /bin/bash

# Start the CLI via telnet. But first wait up to $(MAXWAIT) sec for telnet to come up.
cli: LISTENPORT=2200
cli:
	$(wait-for-listener)
	docker exec -it $(CONTAINER_NAME) telnet 127.0.0.1 2200 ; true

gui: LISTENPORT=9090
gui:
	$(wait-for-listener)
	firefox https://$(DP_DOCKER_HOST):$(shell docker inspect --format='{{(index (index .NetworkSettings.Ports "$(LISTENPORT)/tcp") 0).HostPort}}' $(CONTAINER_NAME)) > /dev/null 2>&1 &

run:
	$(foreach name, $(BACKEND_CONTAINER_NAMES), docker run -d --name $(name) --hostname $(name) hstenzel/nodejs-hostname; ) true
	docker run -d --name $(CONTAINER_NAME) $(RUNFLAGS) $(EXTRA_RUNFLAGS) $(foreach name, $(BACKEND_CONTAINER_NAMES), --link $(name)) $(REGISTRY)/$(REPOSITORY):$(TAG) $(CONTAINER_CMD)

test: LISTENPORT=443
test:
	$(wait-for-listener)
	curl --insecure $(foreach name, $(BACKEND_CONTAINER_NAMES), https://$(DP_DOCKER_HOST):$(shell docker inspect --format='{{(index (index .NetworkSettings.Ports "$(LISTENPORT)/tcp") 0).HostPort}}' $(CONTAINER_NAME))) | sort

stop:
	docker stop -t $(MAXWAIT) $(CONTAINER_NAME) || true

rm: stop
	docker rm $(CONTAINER_NAME) || true
	docker rm -f $(BACKEND_CONTAINER_NAMES) || true

clean:
	rm -f Dockerfile datapower/config/foo/loadbalancer-group.cfg datapower/config/debug.cfg datapower/config/foo/debug.cfg 

# Fix permissions and ownership.
# If new docker-created root files are present; save them.
fixate:
	find datapower/ -user root -print0 | xargs -0 --no-run-if-empty sudo chown --reference=.

logs:
	docker logs $(CONTAINER_NAME) 2>&1

tag:
	docker tag -f $(REGISTRY)/$(REPOSITORY):$(TAG) $(REGISTRY)/$(REPOSITORY):latest

datapower/%:
	mkdir -p $@

